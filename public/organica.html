<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rede Org√¢nica - SNIIC</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0e27;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        #container {
            position: absolute;
            inset: 0;
        }

        .header {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .header h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 40px rgba(102, 126, 234, 0.5);
        }

        .header p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .back-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.6rem 1.2rem;
            background: rgba(102, 126, 234, 0.25);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 8px;
            color: white;
            text-decoration: none;
            font-weight: 600;
            z-index: 101;
            transition: all .3s;
        }

        .back-button:hover {
            background: rgba(102, 126, 234, 0.45);
            transform: translateY(-2px);
        }

        .label {
            position: absolute;
            font-size: 11px;
            font-weight: 600;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            white-space: nowrap;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div class="header">
        <h1>üåø Rede Org√¢nica Viva - SNIIC</h1>
        <p>Arraste para rotacionar ‚Ä¢ Scroll para zoom ‚Ä¢ Observe o organismo respirar</p>
    </div>

    <a href="index.html" class="back-button">‚Üê Voltar</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        let nodes = [];
        let organicConnections = [];
        let flowParticles = [];
        let breathPhase = 0;

        const fontes = {
            estruturantes: [
                'TransfereGov', 'SIAFI', 'SIAPE', 'SIOP', 'ComprasGov', 'SIORG',
                'SICONV', 'SIAFEM', 'SCDP', 'SEI', 'SIGEPE', 'CADIN', 'Portal Transpar√™ncia'
            ],
            finalisticos: [
                'SALIC', 'SNC/SNIIC', 'Sist. Nacional Cultura', 'Editais', 'Cad. Agentes',
                'Cad. Proponentes', 'Pontos Cultura', 'Cultura Viva', 'Aldir Blanc',
                'Paulo Gustavo', 'PNAB', 'Prest. Contas', 'Monitor. Projetos'
            ],
            abertos: [
                'dados.gov.br', 'APIs Gov.', 'CSV/XLSX', 'JSON/XML',
                'Microdados', 'S√©ries Hist.', 'GeoJSON', 'Shapefiles', 'Dados Agregados'
            ],
            documentais: [
                'PDFs Editais', 'Portarias', 'INs', 'Pareceres', 'Rel. Execu√ß√£o',
                'Rel. Gest√£o', 'Atas', 'Resolu√ß√µes', 'Planos Nacionais',
                'Prest. Contas Docs', 'DOU-MinC'
            ]
        };

        const cores = {
            estruturantes: 0xff6b9d,
            finalisticos: 0xffa502,
            abertos: 0x5f27cd,
            documentais: 0x00d2d3,
            sniic: 0xee5a6f
        };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0e27, 50, 200);

            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 0, 90);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0e27);
            document.getElementById('container').appendChild(renderer.domElement);

            // Ilumina√ß√£o din√¢mica
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));

            const light1 = new THREE.PointLight(0xff6b9d, 2.5, 150);
            light1.position.set(30, 30, 30);
            scene.add(light1);

            const light2 = new THREE.PointLight(0x5f27cd, 2, 150);
            light2.position.set(-30, -30, 30);
            scene.add(light2);

            const light3 = new THREE.PointLight(0x00d2d3, 1.5, 150);
            light3.position.set(0, 40, -30);
            scene.add(light3);

            setupControls();
            createOrganicCore();
            createOrganicNetwork();
            startFlowSystem();

            window.addEventListener('resize', onResize);
            animate();

            // Transi√ß√£o autom√°tica para micelial.html ap√≥s 5 segundos
            setTimeout(() => {
                window.location.href = 'micelial.html';
            }, 5000);
        }

        function createOrganicCore() {
            // N√∫cleo org√¢nico central
            const coreGeo = new THREE.IcosahedronGeometry(7, 1);
            const coreMat = new THREE.MeshPhongMaterial({
                color: cores.sniic,
                emissive: cores.sniic,
                emissiveIntensity: 0.6,
                shininess: 100,
                flatShading: true
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            scene.add(core);

            // Membrana externa pulsante
            const membraneGeo = new THREE.IcosahedronGeometry(9, 1);
            const membraneMat = new THREE.MeshPhongMaterial({
                color: cores.sniic,
                transparent: true,
                opacity: 0.15,
                wireframe: true,
                emissive: cores.sniic,
                emissiveIntensity: 0.3
            });
            const membrane = new THREE.Mesh(membraneGeo, membraneMat);
            scene.add(membrane);

            core.userData.label = createLabel('SNIIC');

            nodes.push({
                sphere: core,
                membrane: membrane,
                isCore: true,
                breathPhase: 0,
                rotationSpeed: { x: 0.003, y: 0.005, z: 0.002 }
            });
        }

        function createOrganicNetwork() {
            const radius = 55;
            const allNodes = [];

            Object.keys(fontes).forEach(cat => {
                fontes[cat].forEach(name => {
                    // Distribui√ß√£o org√¢nica
                    const phi = Math.acos(1 - 2 * Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const r = radius + (Math.random() - 0.5) * 15; // Varia√ß√£o radial

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.cos(phi);
                    const z = r * Math.sin(phi) * Math.sin(theta);

                    // N√≥dulo org√¢nico
                    const nodeGeo = new THREE.DodecahedronGeometry(1.8, 0);
                    const nodeMat = new THREE.MeshPhongMaterial({
                        color: cores[cat],
                        emissive: cores[cat],
                        emissiveIntensity: 0.4,
                        shininess: 60,
                        flatShading: true
                    });
                    const node = new THREE.Mesh(nodeGeo, nodeMat);
                    node.position.set(x, y, z);
                    node.userData.label = createLabel(name);
                    node.userData.category = cat;
                    node.userData.color = cores[cat];
                    node.userData.basePosition = node.position.clone();
                    scene.add(node);

                    // Aura org√¢nica
                    const auraGeo = new THREE.IcosahedronGeometry(2.8, 0);
                    const auraMat = new THREE.MeshBasicMaterial({
                        color: cores[cat],
                        transparent: true,
                        opacity: 0.12,
                        wireframe: true
                    });
                    const aura = new THREE.Mesh(auraGeo, auraMat);
                    aura.position.copy(node.position);
                    scene.add(aura);

                    allNodes.push(node);
                    nodes.push({
                        sphere: node,
                        aura: aura,
                        breathPhase: Math.random() * Math.PI * 2,
                        breathSpeed: 0.02 + Math.random() * 0.02,
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.02,
                            y: (Math.random() - 0.5) * 0.02,
                            z: (Math.random() - 0.5) * 0.02
                        },
                        floatOffset: {
                            x: Math.random() * 2,
                            y: Math.random() * 2,
                            z: Math.random() * 2
                        }
                    });
                });
            });

            createOrganicConnections(allNodes);
        }

        function createOrganicConnections(nodeList) {
            const connectionThreshold = 50;

            // Conex√µes entre n√≥s pr√≥ximos
            for (let i = 0; i < nodeList.length; i++) {
                const maxConnections = Math.floor(Math.random() * 2) + 2;
                let connections = 0;

                for (let j = i + 1; j < nodeList.length && connections < maxConnections; j++) {
                    const dist = nodeList[i].position.distanceTo(nodeList[j].position);

                    if (dist < connectionThreshold && Math.random() > 0.65) {
                        createOrganicTube(nodeList[i], nodeList[j]);
                        connections++;
                    }
                }
            }

            // Conectar ao n√∫cleo central
            nodeList.forEach(node => {
                if (Math.random() > 0.82) {
                    createOrganicTube(node, null, true);
                }
            });
        }

        function createOrganicTube(from, to, toCenter = false) {
            const fromPos = from.position;
            const toPos = toCenter ? new THREE.Vector3(0, 0, 0) : to.position;

            // Criar curva org√¢nica (B√©zier)
            const midPoint = new THREE.Vector3()
                .addVectors(fromPos, toPos)
                .multiplyScalar(0.5);

            // Adicionar desvio para tornar curva
            const deviation = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 20
            );
            midPoint.add(deviation);

            const curve = new THREE.QuadraticBezierCurve3(fromPos, midPoint, toPos);
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            const color = toCenter ? from.userData.color : 0x667eea;
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.25,
                linewidth: 2
            });

            const tube = new THREE.Line(geometry, material);
            scene.add(tube);

            organicConnections.push({
                tube: tube,
                curve: curve,
                from: fromPos,
                to: toPos,
                material: material,
                pulsePhase: Math.random() * Math.PI * 2,
                pulseSpeed: 0.02 + Math.random() * 0.03,
                baseOpacity: toCenter ? 0.3 : 0.25,
                isToCenter: toCenter
            });
        }

        function startFlowSystem() {
            // Criar part√≠culas de fluxo org√¢nico
            for (let i = 0; i < 60; i++) {
                setTimeout(() => {
                    if (organicConnections.length > 0) {
                        createFlowParticle();
                    }
                }, Math.random() * 3000);
            }
        }

        function createFlowParticle() {
            if (organicConnections.length === 0) return;

            const connection = organicConnections[Math.floor(Math.random() * organicConnections.length)];

            // Part√≠cula fluida
            const particleGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const particleMat = new THREE.MeshPhongMaterial({
                color: connection.material.color,
                emissive: connection.material.color,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.9
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            scene.add(particle);

            // Tra√ßo de energia
            const trailGeo = new THREE.SphereGeometry(0.8, 8, 8);
            const trailMat = new THREE.MeshBasicMaterial({
                color: connection.material.color,
                transparent: true,
                opacity: 0.4
            });
            const trail = new THREE.Mesh(trailGeo, trailMat);
            scene.add(trail);

            flowParticles.push({
                particle: particle,
                trail: trail,
                curve: connection.curve,
                progress: 0,
                speed: 0.005 + Math.random() * 0.01,
                connection: connection,
                pulsePhase: 0
            });
        }

        function createLabel(text) {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = text;
            document.body.appendChild(div);
            return div;
        }

        function updateLabel(obj) {
            if (!obj.userData.label) return;
            const v = obj.position.clone().project(camera);
            const x = (v.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
            obj.userData.label.style.left = `${x}px`;
            obj.userData.label.style.top = `${y}px`;
            obj.userData.label.style.display = v.z < 1 ? 'block' : 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            breathPhase += 0.01;

            // Rota√ß√£o global suave
            scene.rotation.y += 0.0005;

            // Animar n√≥s org√¢nicos
            nodes.forEach(n => {
                if (n.isCore) {
                    // Respira√ß√£o do n√∫cleo
                    const breathScale = 1 + Math.sin(breathPhase * 1.5) * 0.12;
                    n.sphere.scale.setScalar(breathScale);
                    n.sphere.rotation.x += n.rotationSpeed.x;
                    n.sphere.rotation.y += n.rotationSpeed.y;
                    n.sphere.rotation.z += n.rotationSpeed.z;

                    n.sphere.material.emissiveIntensity = 0.5 + Math.sin(breathPhase * 1.5) * 0.2;

                    if (n.membrane) {
                        n.membrane.scale.setScalar(breathScale * 1.08);
                        n.membrane.rotation.x -= 0.002;
                        n.membrane.rotation.y += 0.003;
                        n.membrane.material.opacity = 0.12 + Math.sin(breathPhase * 1.5) * 0.08;
                    }
                } else {
                    // Respira√ß√£o e flutua√ß√£o dos n√≥s
                    n.breathPhase += n.breathSpeed;
                    const breathScale = 1 + Math.sin(n.breathPhase) * 0.15;
                    n.sphere.scale.setScalar(breathScale);

                    // Movimento org√¢nico (flutua√ß√£o)
                    const basePos = n.sphere.userData.basePosition;
                    n.sphere.position.x = basePos.x + Math.sin(time * 0.5 + n.floatOffset.x) * 2;
                    n.sphere.position.y = basePos.y + Math.sin(time * 0.3 + n.floatOffset.y) * 2;
                    n.sphere.position.z = basePos.z + Math.sin(time * 0.4 + n.floatOffset.z) * 2;

                    // Rota√ß√£o org√¢nica
                    n.sphere.rotation.x += n.rotationSpeed.x;
                    n.sphere.rotation.y += n.rotationSpeed.y;
                    n.sphere.rotation.z += n.rotationSpeed.z;

                    if (n.aura) {
                        n.aura.position.copy(n.sphere.position);
                        n.aura.rotation.x += 0.008;
                        n.aura.rotation.y += 0.01;
                        n.aura.scale.setScalar(breathScale * 1.1);
                    }
                }

                updateLabel(n.sphere);
            });

            // Animar part√≠culas de fluxo
            flowParticles.forEach((p, index) => {
                p.progress += p.speed;
                p.pulsePhase += 0.1;

                if (p.progress >= 1) {
                    scene.remove(p.particle);
                    scene.remove(p.trail);
                    flowParticles.splice(index, 1);

                    setTimeout(() => createFlowParticle(), Math.random() * 1500);
                    return;
                }

                // Mover ao longo da curva
                const point = p.curve.getPoint(p.progress);
                p.particle.position.copy(point);

                const trailPoint = p.curve.getPoint(Math.max(0, p.progress - 0.08));
                p.trail.position.copy(trailPoint);

                // Pulsa√ß√£o da part√≠cula
                const pulse = 1 + Math.sin(p.pulsePhase) * 0.3;
                p.particle.scale.setScalar(pulse);

                // Fade out da trilha
                p.trail.material.opacity = 0.4 * (1 - p.progress);
                p.trail.scale.setScalar(pulse * 1.2);

                // Iluminar conex√£o
                if (p.progress > 0.3 && p.progress < 0.7) {
                    p.connection.material.opacity = p.connection.baseOpacity * 2;
                } else {
                    p.connection.material.opacity = THREE.MathUtils.lerp(
                        p.connection.material.opacity,
                        p.connection.baseOpacity,
                        0.05
                    );
                }
            });

            // Animar conex√µes org√¢nicas (pulsa√ß√£o)
            organicConnections.forEach(conn => {
                conn.pulsePhase += conn.pulseSpeed;
                const pulse = Math.sin(conn.pulsePhase) * 0.5 + 0.5;

                const targetOpacity = conn.baseOpacity + pulse * 0.15;
                conn.material.opacity = THREE.MathUtils.lerp(
                    conn.material.opacity,
                    targetOpacity,
                    0.1
                );
            });

            renderer.render(scene, camera);
        }

        function setupControls() {
            let dragging = false, px = 0, py = 0;

            renderer.domElement.addEventListener('mousedown', e => {
                dragging = true; px = e.clientX; py = e.clientY;
            });
            window.addEventListener('mouseup', () => dragging = false);

            window.addEventListener('mousemove', e => {
                if (!dragging) return;
                scene.rotation.y += (e.clientX - px) * 0.005;
                scene.rotation.x += (e.clientY - py) * 0.005;
                px = e.clientX; py = e.clientY;
            });

            window.addEventListener('wheel', e => {
                camera.position.z = THREE.MathUtils.clamp(
                    camera.position.z + e.deltaY * 0.05, 40, 150
                );
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>